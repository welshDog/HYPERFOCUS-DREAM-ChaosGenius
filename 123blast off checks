#!/usr/bin/env python3
"""
üöÄ BROSKI CLANVERSE ULTRA - BLAST OFF SAFETY CHECKLIST
Ultra Magic Implementation - Real System Validation
"""
import asyncio
import json
import os
import sqlite3
import sys
import time
from datetime import datetime
from pathlib import Path

import requests
from dotenv import load_dotenv

# Add our AI modules to path
sys.path.append("/root/chaosgenius")
from ai_modules.broski.broski_core import BROskiCore
from ai_modules.broski.token_engine import BROskiTokenEngine

print("üßê INITIALIZING ULTRA MAGIC BLAST OFF SEQUENCE...")
print("=" * 60)


## üîê 1. SECRETS & ENV PROTECTION - REAL IMPLEMENTATION
def check_secrets_security():
    """üîê Validate all critical secrets are properly loaded"""
    print("üîê Checking secrets & environment security...")

    load_dotenv()

    critical_secrets = [
        "DISCORD_BOT_TOKEN",
        "OPENAI_API_KEY",
        "ETSY_API_KEY",
        "CLOUDFLARE_API_TOKEN",
    ]

    missing_secrets = []
    for secret in critical_secrets:
        if not os.getenv(secret):
            missing_secrets.append(secret)

    if missing_secrets:
        print(f"‚ö†Ô∏è MISSING SECRETS: {', '.join(missing_secrets)}")
        return False

    # Check .env file permissions (should not be world-readable)
    env_file = Path(".env")
    if env_file.exists():
        permissions = oct(env_file.stat().st_mode)[-3:]
        if permissions != "600":
            print(f"‚ö†Ô∏è .env file permissions too open: {permissions} (should be 600)")
            return False

    print("‚úÖ All secrets secured and loaded properly!")
    return True


## üß™ 2. TEST COVERAGE - REAL IMPLEMENTATIONS
def test_token_system():
    """ü™ô Test BROski$ token minting and transactions"""
    print("üß™ Testing BROski$ token system...")

    try:
        engine = BROskiTokenEngine()

        # Test wallet creation
        test_user = "test_blast_off_user"
        wallet_result = engine.create_wallet(test_user)
        if wallet_result["status"] != "success":
            return False

        # Test token minting
        mint_result = engine.award_tokens(test_user, 10.0, "Blast off test")
        if mint_result["status"] != "success":
            return False

        # Test balance check
        balance = engine.get_balance(test_user)
        if balance < 10.0:
            return False

        # Test transaction
        engine.create_wallet("test_recipient")
        transfer_result = engine.transfer_tokens(
            test_user, "test_recipient", 5.0, "Test transfer"
        )
        if transfer_result["status"] != "success":
            return False

        print("‚úÖ Token system fully operational!")
        return True

    except Exception as e:
        print(f"‚ùå Token system error: {e}")
        return False


def test_broski_ai():
    """üß† Test BROski AI core functionality"""
    print("üß™ Testing BROski AI intelligence...")

    try:
        broski = BROskiCore()

        # Test system status
        status = broski.get_system_status()
        if status["status"] != "FULLY_OPERATIONAL":
            return False

        # Test AI response generation
        test_response = asyncio.run(
            broski.process_user_interaction("test_user", "I'm feeling overwhelmed")
        )

        if not test_response.message or len(test_response.message) < 10:
            return False

        # Test mood detection
        if not test_response.mood_detected:
            return False

        print(
            f"‚úÖ BROski AI operational - Intelligence: {status['system_intelligence']}%"
        )
        return True

    except Exception as e:
        print(f"‚ùå BROski AI error: {e}")
        return False


def test_database_connections():
    """üóÑÔ∏è Test all database connections"""
    print("üß™ Testing database connections...")

    databases = ["chaosgenius.db", "broski_tokens.db", "broski_learning.db"]

    for db_name in databases:
        try:
            conn = sqlite3.connect(db_name)
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            result = cursor.fetchone()
            conn.close()

            if not result:
                print(f"‚ùå Database {db_name} connection failed")
                return False

        except Exception as e:
            print(f"‚ùå Database {db_name} error: {e}")
            return False

    print("‚úÖ All databases connected and responsive!")
    return True


## üîÑ 3. BACKEND FINAL BINDS - REAL API TESTS
def test_api_endpoints():
    """üåê Test Flask API endpoints"""
    print("üß™ Testing API endpoints...")

    try:
        # Test if dashboard API is running
        response = requests.get("http://localhost:5000/api/status", timeout=3)
        if response.status_code != 200:
            print("‚ö†Ô∏è Dashboard API not responding")
            return False

        # Test health endpoint
        response = requests.get("http://localhost:5000/api/health", timeout=3)
        if response.status_code != 200:
            print("‚ö†Ô∏è Health endpoint not responding")
            return False

        print("‚úÖ All API endpoints responding!")
        return True

    except requests.exceptions.RequestException:
        print("‚ö†Ô∏è API server not running - will start during launch")
        return True  # Not critical for blast off


## ü§ñ 4. DISCORD BOT HEALTH CHECK
def test_discord_bot():
    """ü§ñ Verify Discord bot configuration"""
    print("üß™ Testing Discord bot configuration...")

    try:
        # Check if bot token is valid format
        token = os.getenv("DISCORD_BOT_TOKEN")
        if not token or len(token) < 50:
            print("‚ùå Invalid Discord bot token")
            return False

        # Check bot script exists and is valid Python
        bot_file = Path("chaosgenius_discord_bot.py")
        if not bot_file.exists():
            print("‚ùå Discord bot file missing")
            return False

        # Basic syntax check
        with open(bot_file, "r") as f:
            content = f.read()
            if "@bot.command" not in content:
                print("‚ùå Discord bot commands not found")
                return False

        print("‚úÖ Discord bot ready for deployment!")
        return True

    except Exception as e:
        print(f"‚ùå Discord bot check error: {e}")
        return False


## ü™ô 5. BROSKI$ WALLET SECURITY
def test_wallet_security():
    """üîê Test wallet encryption and backup systems"""
    print("üß™ Testing BROski$ wallet security...")

    try:
        # Check wallet file exists and is properly formatted
        wallet_file = Path("broski_wallets_SECURE.json")
        if wallet_file.exists():
            with open(wallet_file, "r") as f:
                wallets = json.load(f)
                if not isinstance(wallets, dict):
                    print("‚ùå Wallet file corrupted")
                    return False

        # Check encryption key exists
        key_file = Path("broski_encryption.key")
        if not key_file.exists():
            print("‚ö†Ô∏è Encryption key missing - will generate during launch")

        # Check token database
        token_db = Path("broski_tokens.db")
        if token_db.exists():
            conn = sqlite3.connect("broski_tokens.db")
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM transactions")
            count = cursor.fetchone()[0]
            conn.close()
            print(f"üìä {count} transactions in token database")

        print("‚úÖ Wallet security systems operational!")
        return True

    except Exception as e:
        print(f"‚ùå Wallet security error: {e}")
        return False


## üíª 6. WEB DASHBOARD VALIDATION
def test_dashboard_files():
    """üíª Check web dashboard files and assets"""
    print("üß™ Testing web dashboard components...")

    critical_files = ["dashboard.html", "dashboard_api.py", "app.py"]

    for file_name in critical_files:
        file_path = Path(file_name)
        if not file_path.exists():
            print(f"‚ùå Missing critical file: {file_name}")
            return False

    # Check HTML file has required elements
    with open("dashboard.html", "r") as f:
        html_content = f.read()
        if "BROski" not in html_content:
            print("‚ö†Ô∏è Dashboard may not be properly branded")

    print("‚úÖ Dashboard files validated!")
    return True


## üåê 7. DOMAIN & SSL READINESS
def test_domain_config():
    """üåê Test domain and SSL configuration"""
    print("üß™ Testing domain configuration...")

    try:
        # Check if we have domain configuration
        config_files = ["cloudflare_config.json", "domain_config.json"]
        domain_configured = any(Path(f).exists() for f in config_files)

        if not domain_configured:
            print("‚ö†Ô∏è Domain not configured - running locally")
            return True

        # Test local SSL cert if exists
        ssl_files = ["server.crt", "server.key"]
        ssl_ready = all(Path(f).exists() for f in ssl_files)

        if ssl_ready:
            print("‚úÖ SSL certificates found!")
        else:
            print("‚ö†Ô∏è SSL will be handled by Cloudflare")

        print("‚úÖ Domain configuration ready!")
        return True

    except Exception as e:
        print(f"‚ùå Domain config error: {e}")
        return False


## üî• 8. ULTRA UX PERFORMANCE
def test_performance_metrics():
    """‚ö° Test system performance and responsiveness"""
    print("üß™ Testing system performance...")

    try:
        # Test file system performance
        start_time = time.time()
        test_file = Path("performance_test.tmp")
        with open(test_file, "w") as f:
            f.write("performance test" * 1000)
        test_file.unlink()
        file_io_time = time.time() - start_time

        if file_io_time > 1.0:
            print(f"‚ö†Ô∏è Slow file I/O: {file_io_time:.2f}s")
            return False

        # Test database query performance
        start_time = time.time()
        conn = sqlite3.connect("chaosgenius.db")
        cursor = conn.cursor()
        cursor.execute("SELECT 1")
        cursor.fetchone()
        conn.close()
        db_time = time.time() - start_time

        if db_time > 0.5:
            print(f"‚ö†Ô∏è Slow database: {db_time:.2f}s")
            return False

        print(
            f"‚úÖ Performance optimal! File I/O: {file_io_time:.3f}s, DB: {db_time:.3f}s"
        )
        return True

    except Exception as e:
        print(f"‚ùå Performance test error: {e}")
        return False


## üõ°Ô∏è ULTRA SAFETY NET
def setup_monitoring():
    """üõ°Ô∏è Setup error monitoring and alerts"""
    print("üõ°Ô∏è Setting up monitoring systems...")

    try:
        # Create logs directory
        logs_dir = Path("logs")
        logs_dir.mkdir(exist_ok=True)

        # Create monitoring subdirectories
        (logs_dir / "discord_bot").mkdir(exist_ok=True)
        (logs_dir / "api").mkdir(exist_ok=True)
        (logs_dir / "tokens").mkdir(exist_ok=True)

        # Create health check file
        health_file = logs_dir / "system_health.json"
        health_data = {
            "last_check": datetime.now().isoformat(),
            "status": "operational",
            "checks_passed": 0,
            "total_checks": 0,
        }

        with open(health_file, "w") as f:
            json.dump(health_data, f, indent=2)

        print("‚úÖ Monitoring systems configured!")
        return True

    except Exception as e:
        print(f"‚ùå Monitoring setup error: {e}")
        return False


## üöÄ MASTER BLAST OFF SEQUENCE
def execute_blast_off_checklist():
    """üöÄ Execute complete pre-launch validation"""
    print("\n" + "üöÄ" * 20)
    print("BROSKI CLANVERSE ULTRA - BLAST OFF SEQUENCE INITIATED")
    print("üöÄ" * 20 + "\n")

    checks = [
        ("üîê Secrets Security", check_secrets_security),
        ("ü™ô Token System", test_token_system),
        ("üß† BROski AI", test_broski_ai),
        ("üóÑÔ∏è Databases", test_database_connections),
        ("üåê API Endpoints", test_api_endpoints),
        ("ü§ñ Discord Bot", test_discord_bot),
        ("üí∞ Wallet Security", test_wallet_security),
        ("üíª Dashboard", test_dashboard_files),
        ("üåê Domain Config", test_domain_config),
        ("‚ö° Performance", test_performance_metrics),
        ("üõ°Ô∏è Monitoring", setup_monitoring),
    ]

    passed_checks = 0
    total_checks = len(checks)
    failed_checks = []

    for check_name, check_function in checks:
        print(f"\n{'='*60}")
        print(f"Running: {check_name}")
        print("=" * 60)

        try:
            result = check_function()
            if result:
                passed_checks += 1
                print(f"‚úÖ {check_name}: PASSED")
            else:
                failed_checks.append(check_name)
                print(f"‚ùå {check_name}: FAILED")
        except Exception as e:
            failed_checks.append(check_name)
            print(f"üí• {check_name}: CRASHED - {e}")

    # Final blast off decision
    print("\n" + "üéØ" * 20)
    print("BLAST OFF CHECKLIST RESULTS")
    print("üéØ" * 20)
    print(f"‚úÖ Passed: {passed_checks}/{total_checks}")
    print(f"‚ùå Failed: {len(failed_checks)}")

    if failed_checks:
        print(f"üö® Failed Checks: {', '.join(failed_checks)}")

    success_rate = (passed_checks / total_checks) * 100

    if success_rate >= 90:
        print(f"\nüöÄ BLAST OFF APPROVED! Success Rate: {success_rate:.1f}%")
        print("üåü BROski ClanVerse Ultra is GO FOR LAUNCH! üåü")
        return True
    elif success_rate >= 75:
        print(f"\n‚ö†Ô∏è CONDITIONAL LAUNCH: Success Rate: {success_rate:.1f}%")
        print("üõ†Ô∏è Some issues detected but system is functional")
        return True
    else:
        print(f"\nüö® LAUNCH ABORTED! Success Rate: {success_rate:.1f}%")
        print("üîß Critical issues must be resolved before launch")
        return False


if __name__ == "__main__":
    print("üí™ ULTRA MAGIC ACTIVATED - FULL SYSTEM VALIDATION!")
    print("üëä Checking every component of the BROski empire...")

    launch_approved = execute_blast_off_checklist()

    if launch_approved:
        print("\n" + "üéâ" * 30)
        print("üöÄ BROSKI CLANVERSE ULTRA: CLEARED FOR TAKEOFF! üöÄ")
        print("‚ò¢Ô∏è All systems nominal - ready to dominate! ‚ò¢Ô∏è")
        print("üéâ" * 30)
    else:
        print("\n" + "üîß" * 30)
        print("üõ†Ô∏è SYSTEMS REQUIRE ATTENTION BEFORE LAUNCH")
        print("‚ö° Fix issues and run blast off checks again!")
        print("üîß" * 30)
